<!doctype html>
<html
    xmlns="http://www.w3.org/1999/xhtml"
    lang=""
    xml:lang=""
    >
    <head>
        <meta charset="utf-8" />
        <meta name="generator" content="pandoc" />
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1.0, user-scalable=yes"
        />
                   <title>EXPLANATION_PSET1</title>
        <style>
            code{white-space: pre-wrap;}
            span.smallcaps{font-variant: small-caps;}
            div.columns{display: flex; gap: min(4vw, 1.5em);}
            div.column{flex: auto; overflow-x: auto;}
            div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
            /* The extra [class] is a hack that increases specificity enough to
               override a similar rule in reveal.js */
            ul.task-list[class]{list-style: none;}
            ul.task-list li input[type="checkbox"] {
              font-size: inherit;
              width: 0.8em;
              margin: 0 0.8em 0.2em -1.6em;
              vertical-align: middle;
            }
        </style>
                <link rel="stylesheet" href="/pandoc-templates/docs.css" />
         
        <script
            data-external="1"
            src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
        ></script>
        <script>
        // Tabset functionality for pandoc-rendered markdown
        // Emulates R Markdown's {.tabset} behavior
        document.addEventListener('DOMContentLoaded', function() {
          // Find all headers with 'tabset' class (pandoc applies class to header, not section)
          document.querySelectorAll('h1.tabset, h2.tabset, h3.tabset, h4.tabset, h5.tabset, h6.tabset').forEach(function(tabsetHeader) {
            const tabLevel = parseInt(tabsetHeader.tagName[1]);
            const childHeaderTag = 'H' + (tabLevel + 1);
            
            // Find all child sections (tabs) - siblings until next same-level header
            const tabs = [];
            const introContent = []; // Content before first tab
            let currentTab = null;
            
            let sibling = tabsetHeader.nextElementSibling;
            while (sibling) {
              if (sibling.tagName === childHeaderTag) {
                // New tab starts
                if (currentTab) tabs.push(currentTab);
                currentTab = {
                  title: sibling.textContent,
                  id: sibling.id || sibling.textContent.toLowerCase().replace(/\s+/g, '-'),
                  header: sibling,
                  content: []
                };
              } else if (sibling.tagName && sibling.tagName[0] === 'H' && parseInt(sibling.tagName[1]) <= tabLevel) {
                // Hit a same-level or higher header, stop
                break;
              } else if (currentTab) {
                // Add content to current tab
                currentTab.content.push(sibling);
              } else {
                // Content before first tab (intro text)
                introContent.push(sibling);
              }
              sibling = sibling.nextElementSibling;
            }
            if (currentTab) tabs.push(currentTab);
            
            if (tabs.length === 0) return;
            
            // Create tab UI
            const tabContainer = document.createElement('div');
            tabContainer.className = 'tab-container';
            
            // Create tab buttons
            const tabButtons = document.createElement('div');
            tabButtons.className = 'tab-buttons';
            
            tabs.forEach(function(tab, index) {
              const button = document.createElement('button');
              button.className = 'tab-button' + (index === 0 ? ' active' : '');
              button.textContent = tab.title;
              button.setAttribute('data-tab', tab.id);
              button.addEventListener('click', function() {
                // Deactivate all tabs in this container
                tabContainer.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
                tabContainer.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
                // Activate clicked tab
                button.classList.add('active');
                tabContainer.querySelector('.tab-panel[data-tab="' + tab.id + '"]').classList.add('active');
              });
              tabButtons.appendChild(button);
            });
            
            tabContainer.appendChild(tabButtons);
            
            // Create tab panels and move content
            tabs.forEach(function(tab, index) {
              const panel = document.createElement('div');
              panel.className = 'tab-panel' + (index === 0 ? ' active' : '');
              panel.setAttribute('data-tab', tab.id);
              tab.content.forEach(function(el) {
                panel.appendChild(el);
              });
              tabContainer.appendChild(panel);
              // Remove the original tab header
              tab.header.remove();
            });
            
            // Insert intro content right after tabset header, then tab container
            let insertPoint = tabsetHeader;
            introContent.forEach(function(el) {
              insertPoint.after(el);
              insertPoint = el;
            });
            insertPoint.after(tabContainer);
          });
        });
        </script>
    </head>
    <body>
                  <nav id="TOC" role="doc-toc">
             <ul>
<li><a
href="#guía-del-proyecto-01-design-systems---demand-prediction-service"
id="toc-guía-del-proyecto-01-design-systems---demand-prediction-service">Guía
del Proyecto 01: Design Systems - Demand Prediction Service</a>
<ul>
<li><a href="#glosario-general-conceptos-clave"
id="toc-glosario-general-conceptos-clave">1. Glosario General (Conceptos
Clave)</a></li>
<li><a href="#objetivo-general" id="toc-objetivo-general">2. Objetivo
General</a></li>
<li><a href="#desglose-de-instrucciones-por-componente"
id="toc-desglose-de-instrucciones-por-componente">3. Desglose de
Instrucciones por Componente</a>
<ul>
<li><a href="#a.-el-backend-api---fastapi"
id="toc-a.-el-backend-api---fastapi">A. El Backend (API -
FastAPI)</a></li>
<li><a href="#b.-el-frontend-app---streamlit"
id="toc-b.-el-frontend-app---streamlit">B. El Frontend (App -
Streamlit)</a></li>
<li><a href="#c.-la-lógica-de-upload-carga-de-datos"
id="toc-c.-la-lógica-de-upload-carga-de-datos">C. La Lógica de “Upload”
(Carga de Datos)</a></li>
<li><a href="#d.-infraestructura-y-devops"
id="toc-d.-infraestructura-y-devops">D. Infraestructura y
DevOps</a></li>
</ul></li>
<li><a href="#estructura-del-repositorio"
id="toc-estructura-del-repositorio">4. Estructura del
Repositorio</a></li>
<li><a href="#rúbrica-de-evaluación-y-checklist-final"
id="toc-rúbrica-de-evaluación-y-checklist-final">5. Rúbrica de
Evaluación y Checklist Final</a>
<ul>
<li><a href="#a.-git-github-20-puntos"
id="toc-a.-git-github-20-puntos">A. Git &amp; GitHub (20
Puntos)</a></li>
<li><a href="#b.-docker-compose-25-puntos"
id="toc-b.-docker-compose-25-puntos">B. Docker &amp; Compose (25
Puntos)</a></li>
<li><a href="#c.-fastapi-crud-zones-routes-30-puntos"
id="toc-c.-fastapi-crud-zones-routes-30-puntos">C. FastAPI: CRUD Zones +
Routes (30 Puntos)</a></li>
<li><a href="#d.-upload-parquet-15-puntos"
id="toc-d.-upload-parquet-15-puntos">D. Upload Parquet (15
Puntos)</a></li>
<li><a href="#e.-streamlit-ux-10-puntos"
id="toc-e.-streamlit-ux-10-puntos">E. Streamlit UX (10 Puntos)</a></li>
</ul></li>
</ul></li>
</ul>
        </nav>
         <h1
id="guía-del-proyecto-01-design-systems---demand-prediction-service">Guía
del Proyecto 01: Design Systems - Demand Prediction Service</h1>
<h2 id="glosario-general-conceptos-clave">1. Glosario General (Conceptos
Clave)</h2>
<p>Antes de empezar, definamos los términos que aparecen en todo el
documento:</p>
<ul>
<li><strong>MVP (Minimum Viable Product):</strong> Producto Mínimo
Viable. No se pide un sistema perfecto, sino uno que cumpla las
<em>funciones esenciales</em> descritas en el alcance.</li>
<li><strong>CRUD (Create, Read, Update, Delete):</strong> Son las 4
operaciones básicas de cualquier sistema de datos: Crear, Leer,
Actualizar y Borrar.</li>
<li><strong>Endpoint:</strong> Es una dirección específica en nuestra
API (ej. <code>/zones</code> o <code>/health</code>) a la que el
Frontend le pide datos o le envía información.</li>
<li><strong>Parquet (<code>.parquet</code>):</strong> Un formato de
archivo para guardar datos (como un Excel super eficiente y comprimido).
Se usa en el proyecto para manejar los datos de viajes de taxi de
NYC.</li>
<li><strong>Microservicios:</strong> Arquitectura donde dividimos el
programa en piezas independientes. Aquí tendremos dos:
<strong>Backend</strong> (API) y <strong>Frontend</strong> (App).</li>
<li><strong>Docker Compose:</strong> Herramienta para “encender” todos
nuestros servicios al mismo tiempo y asegurar que se conecten entre
ellos.</li>
</ul>
<hr />
<h2 id="objetivo-general">2. Objetivo General</h2>
<p>Vamos a construir un <strong>“Demand Prediction Service”</strong>
(Sistema de Predicción de Demanda). Imaginen que es el sistema interno
para una app de transporte.</p>
<p>El sistema consta de dos aplicaciones que corren simultáneamente: 1.
<strong>Backend (<code>api</code>):</strong> Hecho con
<strong>FastAPI</strong>. Es el cerebro que procesa y guarda los datos.
2. <strong>Frontend (<code>app</code>):</strong> Hecho con
<strong>Streamlit</strong>. Es la web visual donde el usuario
interactúa.</p>
<hr />
<h2 id="desglose-de-instrucciones-por-componente">3. Desglose de
Instrucciones por Componente</h2>
<h3 id="a.-el-backend-api---fastapi">A. El Backend (API - FastAPI)</h3>
<p><em>Referencia en PDF: Sección 4 (Páginas 3-4)</em></p>
<p>El objetivo es construir una API REST que corra en el puerto 8000.
Debe seguir estrictamente las especificaciones de endpoints
descritos.</p>
<p><strong>1. Persistencia (Regla Crítica)</strong> *
<strong>Regla:</strong> La persistencia debe ser <strong>en
memoria</strong> (<code>dict</code>) para este PSet #1. *
<em>Significado:</em> No usaremos base de datos SQL todavía. Los datos
se guardan en variables de Python. Si reiniciamos el servidor, se
borran.</p>
<p><strong>2. Health Check (Punto 4.1)</strong> *
<strong>Endpoint:</strong> <code>GET /health</code> * <strong>Qué
hace:</strong> Devuelve <code>{ "status": "ok" }</code>. Sirve para
confirmar que el servicio vive.</p>
<p><strong>3. CRUD de Zones (Punto 4.2)</strong> Deben implementar las
operaciones para la entidad <code>Zone</code> (lugares físicos). *
<strong>Endpoints:</strong> <code>POST</code>, <code>GET</code>,
<code>GET /{id}</code>, <code>PUT /{id}</code>,
<code>DELETE /{id}</code>. * <strong>Validaciones Obligatorias:</strong>
* <code>id</code>: Debe ser positivo. * <code>zone_name</code> y
<code>borough</code>: No pueden estar vacíos.</p>
<p><strong>4. CRUD de Routes (Punto 4.3)</strong> La entidad
<code>Route</code> conecta dos zonas (<code>pickup</code> y
<code>dropoff</code>). * <strong>Endpoints:</strong> <code>POST</code>,
<code>GET</code>, <code>GET /{id}</code>, <code>PUT /{id}</code>,
<code>DELETE /{id}</code>. * <strong>Reglas de Negocio
Críticas:</strong> * <strong>Validación de Existencia:</strong> Los
campos <code>pickup_zone_id</code> y <code>dropoff_zone_id</code> deben
corresponder a zonas que <em>ya existen</em>. Si no, devolver error
<strong>400</strong>. * <strong>Lógica de Ruta:</strong> El origen y
destino NO pueden ser iguales (<code>pickup != dropoff</code>). Si son
iguales, error <strong>400</strong>. * <strong>Nombre:</strong> Debe
tener al menos 3 caracteres.</p>
<hr />
<h3 id="b.-el-frontend-app---streamlit">B. El Frontend (App -
Streamlit)</h3>
<p><em>Referencia en PDF: Sección 5 (Página 4)</em></p>
<p>La aplicación debe correr en el puerto 8501 y consumir la API
mediante HTTP.</p>
<p><strong>1. Configuración de Conexión</strong> * La URL del backend
debe ser configurable (<code>API_URL</code>). No la escriban fija
(“hardcoded”) porque debe funcionar tanto en <code>localhost</code> como
dentro de Docker (<code>http://api:8000</code>).</p>
<p><strong>2. Página Home (Punto 5.1)</strong> * Debe mostrar el título
y el <strong>estado del backend</strong> (llamando a
<code>/health</code>).</p>
<p><strong>3. Páginas de Gestión (Punto 5.2)</strong> *
<strong>Zones:</strong> Tabla para listar y formularios para
Crear/Editar/Eliminar. * <strong>Routes:</strong> * <em>Requisito
UX:</em> Para seleccionar las zonas de origen/destino, deben usar
<strong>Dropdowns</strong> (listas desplegables) que carguen las zonas
disponibles desde el endpoint <code>/zones</code>.</p>
<hr />
<h3 id="c.-la-lógica-de-upload-carga-de-datos">C. La Lógica de “Upload”
(Carga de Datos)</h3>
<p><em>Referencia en PDF: Sección 6 (Páginas 5-7)</em></p>
<p>Esta funcionalidad procesa datos reales de viajes.</p>
<p><strong>1. El Flujo de Trabajo (Punto 6.4)</strong> 1.
<strong>Leer:</strong> El backend recibe el archivo
<code>.parquet</code> y lo lee con Pandas. Deben usar
<code>limit_rows</code> para evitar llenar la memoria. 2.
<strong>Analizar:</strong> Calcular los pares
(<code>PULocationID</code>, <code>DOLocationID</code>) más frecuentes y
elegir el <strong>Top N</strong>. 3. <strong>Upsert (Crear o
Actualizar):</strong> * El sistema recorre esas rutas Top N. * Si la
ruta <em>no existe</em> -&gt; Llama a crear (<code>POST</code>). * Si la
ruta <em>ya existe</em> -&gt; Llama a actualizar (<code>PUT</code>). 4.
<strong>Zonas:</strong> Durante la carga, si se detectan zonas nuevas en
el archivo, también deben crearse.</p>
<p><strong>2. Respuesta del Endpoint (Punto 6.2)</strong> El backend
debe devolver un JSON con un resumen exacto de qué pasó (filas leídas,
rutas creadas vs actualizadas, errores).</p>
<hr />
<h3 id="d.-infraestructura-y-devops">D. Infraestructura y DevOps</h3>
<p><em>Referencia en PDF: Secciones 7 y 8 (Páginas 7-8)</em></p>
<p><strong>1. Dockerización</strong> * Un <code>Dockerfile</code>
independiente para el backend y otro para el frontend. * Un
<code>docker-compose.yml</code> en la raíz que levante ambos servicios y
configure la red.</p>
<p><strong>2. Git &amp; GitHub</strong> * <strong>Ramas:</strong> Usar
ramas de <code>feature/...</code> o <code>fix/...</code>. Todo entra por
Pull Request (PR). * <strong>Evidencia:</strong> Se requieren al menos 5
Issues reales y 2 PRs con review.</p>
<hr />
<h2 id="estructura-del-repositorio">4. Estructura del Repositorio</h2>
<p>Debemos respetar esta estructura de archivos obligatoria:</p>
<pre class="text"><code>/ (Raíz del proyecto)
├── docker-compose.yml       # Orquestador
├── README.md                # Instrucciones de uso
├── CONTRIBUTING.md          # Reglas del equipo
├── backend/
│   ├── Dockerfile
│   ├── requirements.txt
│   ├── app/
│   │   ├── main.py          # App FastAPI
│   │   ├── routes_zones.py
│   │   ├── routes_routes.py
│   │   ├── storage.py       # Diccionarios (Memoria)
│   │   └── ...
├── frontend/
│   ├── Dockerfile
│   ├── requirements.txt
│   ├── app/
│   │   ├── Home.py          # Página principal
│   │   └── pages/
│   │       ├── 1_Zones.py
│   │       ├── 2_Routes.py
│   │       └── 3_Upload_Parquet.py
</code></pre>
<hr />
<h2 id="rúbrica-de-evaluación-y-checklist-final">5. Rúbrica de
Evaluación y Checklist Final</h2>
<p>Esta sección detalla los criterios exactos con los que se calificará
el proyecto (Total: 100 Puntos) y la lista de verificación obligatoria
para el README.</p>
<h3 id="a.-git-github-20-puntos">A. Git &amp; GitHub (20 Puntos)</h3>
<p><em>Fuente: PDF Sección 11</em> * [ ] <strong>Issues:</strong> Deben
tener al menos 5 issues creados describiendo tareas reales (ej. “Crear
endpoint de users”, “Arreglar bug de docker”). * [ ] <strong>Pull
Requests (PRs):</strong> Mínimo 2 PRs que incluyan revisión o
comentarios de otros miembros del equipo. * [ ] <strong>Uso de
Ramas:</strong> No subir todo directo a <code>main</code>. Usar ramas
como <code>feature/nueva-funcionalidad</code> o
<code>fix/error-x</code>. * [ ] <strong>Tags:</strong> Usar tags de git
para marcar versiones (opcional pero recomendado en la rúbrica).</p>
<h3 id="b.-docker-compose-25-puntos">B. Docker &amp; Compose (25
Puntos)</h3>
<p><em>Fuente: PDF Sección 11</em> * [ ] <strong>Build
Reproducible:</strong> El comando <code>docker compose up --build</code>
debe levantar todo el sistema (backend y frontend) sin errores y sin que
el profesor tenga que instalar librerías extra. * [ ] <strong>Networking
Correcto:</strong> El contenedor de Streamlit (<code>app</code>) debe
poder comunicarse con la API (<code>api</code>) usando la red interna de
Docker (ej. <code>http://api:8000</code>).</p>
<h3 id="c.-fastapi-crud-zones-routes-30-puntos">C. FastAPI: CRUD Zones +
Routes (30 Puntos)</h3>
<p><em>Fuente: PDF Sección 11</em> * [ ] <strong>Endpoints
Completos:</strong> Deben funcionar <code>GET</code>, <code>POST</code>,
<code>PUT</code>, <code>DELETE</code> para ambas entidades
(<code>Zones</code> y <code>Routes</code>). * [ ]
<strong>Validaciones:</strong> * Error <strong>400</strong>: Para reglas
de negocio (ej. Origen y Destino son iguales). * Error
<strong>404</strong>: Cuando se busca un ID que no existe. * Error
<strong>422</strong>: Validación automática de tipos (Pydantic).</p>
<h3 id="d.-upload-parquet-15-puntos">D. Upload Parquet (15 Puntos)</h3>
<p><em>Fuente: PDF Sección 11</em> * [ ] <strong>Flujo
Completo:</strong> El sistema recibe el archivo, lo procesa y
<strong>crea o actualiza</strong> las rutas en memoria automáticamente.
* [ ] <strong>Resumen:</strong> El usuario debe ver un resumen con el
conteo de: filas leídas, rutas creadas, rutas actualizadas y
errores.</p>
<h3 id="e.-streamlit-ux-10-puntos">E. Streamlit UX (10 Puntos)</h3>
<p><em>Fuente: PDF Sección 11</em> * [ ] <strong>Navegación:</strong>
Menú lateral o botones para ir a “Home”, “Zones”, “Routes” y “Upload”. *
[ ] <strong>Manejo de Errores:</strong> Si la API falla, la interfaz
debe mostrar un mensaje amigable, no el error crudo de Python.</p> 
    </body>
</html>
